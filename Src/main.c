/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <GPIO.h>
#include <main.h>
#include "SPI.h"
#include <string.h>
#include <stm32f407xx.h>

/*
 * PB14 --> SPI2_MISO
 * PB15 --> SPI2_MOSI
 * PB13 -> SPI2_SCLK
 * PB9 --> SPI2_NSS
 * ALT function mode : 5
 */

// SPI Handle for SPI2 (can be used for other SPI peripherals as well)
SPI_Handle_t spi_handle;
GPIO_Handle_t gpio_handle;
uint16_t RX_data[1000];
// Function to configure SPI GPIO pins
//void SPI_GPIO_Init(SPI_Handle_t* spiHandle, GPIO_Handle_t* gpioHandle) {
// SPI_GPIO_Init(spiHandle, gpioHandle);
//}

// Function to configure SPI settings
void SPI_Init_Master_Config(SPI_Handle_t *spiHandle, SPI_TypeDef *SPIx,
		GPIO_TypeDef *GPIOx, uint32_t clkPin, uint32_t mosiPin,
		uint32_t misoPin) {
	GPIO_ClockControl(GPIOB);

	// Set SPI configuration
	spiHandle->pSPIx = SPIx;
	spiHandle->SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
	spiHandle->SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_MASTER_FD; // Full-Duplex
	spiHandle->SPIConfig.SPI_SclkSpeed = SPI_SCLK_SPEED_DIV2;
	spiHandle->SPIConfig.SPI_DFF = SPI_DFF_8BITS;  // 8-bit data frame format
	spiHandle->SPIConfig.SPI_CPOL = SPI_CPOL_HIGH; // idle state is high
	spiHandle->SPIConfig.SPI_CPHA = SPI_CPHA_LOW;  // data captured on 1st edge
	spiHandle->SPIConfig.SPI_SSM = SPI_SSM_DI;  // Hardware NSS Management
	spiHandle->SPIConfig.SPI_SSOE = SPI_SSOE_EN; // if set Automatically drive NSS low during tx of data
	spiHandle->SPIConfig.SPI_SSI = SPI_SSI_DI;// ENABLE internally NSS connected to GND

	spiHandle->SPIConfig.GPIO_NSS.pGPIOx = GPIOB;
	spiHandle->SPIConfig.GPIO_NSS.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_9;
	spiHandle->SPIConfig.GPIO_CLK.pGPIOx = GPIOB;
	spiHandle->SPIConfig.GPIO_CLK.GPIO_PinConfig.GPIO_PinNumber = 13;
	spiHandle->SPIConfig.GPIO_MOSI.pGPIOx = GPIOB;
	spiHandle->SPIConfig.GPIO_MOSI.GPIO_PinConfig.GPIO_PinNumber = 15;

	spiHandle->SPIConfig.GPIO_MISO.pGPIOx = GPIOB;
	spiHandle->SPIConfig.GPIO_MISO.GPIO_PinConfig.GPIO_PinNumber = 14;

	// SPI Pin Configuration

}

void SPI_Init_Slave_Config(SPI_Handle_t *spiHandle, SPI_TypeDef *SPIx,
		GPIO_TypeDef *GPIOx, uint32_t clkPin, uint32_t mosiPin,
		uint32_t misoPin) {
	GPIO_ClockControl(GPIOA);
	// Set SPI configuration
	spiHandle->pSPIx = SPIx;
	spiHandle->SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_SLAVE;
	spiHandle->SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_MASTER_FD; // Full-Duplex
	spiHandle->SPIConfig.SPI_SclkSpeed = SPI_SCLK_SPEED_DIV2;
	spiHandle->SPIConfig.SPI_DFF = SPI_DFF_8BITS;  // 8-bit data frame format
	spiHandle->SPIConfig.SPI_CPOL = SPI_CPOL_HIGH; // idle state is high
	spiHandle->SPIConfig.SPI_CPHA = SPI_CPHA_LOW;  // data captured on 1st edge
	spiHandle->SPIConfig.SPI_SSM = SPI_SSM_DI;  // Hardware NSS Management
	spiHandle->SPIConfig.SPI_SSOE = SPI_SSOE_DI; // if set Automatically drive NSS low during tx of data
	spiHandle->SPIConfig.SPI_SSI = SPI_SSI_DI;// ENABLE internally NSS connected to GND

	spiHandle->SPIConfig.GPIO_NSS.pGPIOx = GPIOA;
	spiHandle->SPIConfig.GPIO_NSS.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_4;
	spiHandle->SPIConfig.GPIO_CLK.pGPIOx = GPIOA;
	spiHandle->SPIConfig.GPIO_CLK.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_5;
	spiHandle->SPIConfig.GPIO_MOSI.pGPIOx = GPIOA;
	spiHandle->SPIConfig.GPIO_MOSI.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_7;

	spiHandle->SPIConfig.GPIO_MISO.pGPIOx = GPIOA;
	spiHandle->SPIConfig.GPIO_MISO.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_6;


	// SPI Pin Configuration

}

// SPI Initialization function
void SPI_Init_Peripheral(SPI_Handle_t *spiHandle) {
	SPI_Init(spiHandle);
}

// SPI Enable function
void SPI_Enable_Peripheral(SPI_Handle_t *spiHandle) {
	SPI_Enable(spiHandle);
}

// SPI Reset Configuration function
int8_t SPI_Reset_Configuration(SPI_Handle_t *spiHandle) {
	return SPI_Configuration_Reset(spiHandle);
}

// Main function
int main(void) {
	char user_data[] = "HELLO DATA SPI";
	// Initialize the system clock
	//MCU_Clock_Setup();

	 // Separate handles for master and slave to avoid conflicts
	 SPI_Handle_t spi_handle_master, spi_handle_slave;
	// Set up SPI2 configuration (MASTER)
	SPI_Init_Master_Config(&spi_handle_master, SPI2, GPIOB, GPIO_PIN_13, GPIO_PIN_15,
	GPIO_PIN_14);

	// Initialize SPI2 peripheral (MASTER)
	SPI_Init_Peripheral(&spi_handle_master);

	// Set up SPI1 configuration (SLAVE)
	SPI_Init_Slave_Config(&spi_handle_slave,SPI1,GPIOA,GPIO_PIN_5,GPIO_PIN_7,GPIO_PIN_6);


	// Initialize SPI1 peripheral (SLAVE)
	SPI_Init_Peripheral(&spi_handle_slave);


	// Reset SPI configuration to default values and check result
	//int8_t result = SPI_Reset_Configuration(&spi_handle);

	// Send data via SPI in polling mode
  SPI_SEND_DATA_POLLING(&spi_handle_master, (uint8_t*) user_data, strlen(user_data));

//	while (SPI_GetFlags_Status(spi_handle.pSPIx, _SPI_SR_BSY) == FLAG_SET);
//	// Handle error (invalid SPI peripheral),De-initialize SPI peripheral (if needed after use as u don't want to use spix where x=1,2,3 for further communication )
//	SPI_DeInit(&spi_handle);

	// Main loop
	while (1) {
		 SPI_RECIEVE_DATA_POLLING(&spi_handle_slave, RX_data, strlen(user_data));
	}

}

//
//#include <GPIO.h>
//#include <main.h>
//#include "SPI.h"
//SPI_Handle_t spi2_handle;
////GPIO_Handle_t spi2;
//GPIO_Handle_t  spi2;
//
//void SPI2_GPIO_INIT(void) {
//
//   SPI_GPIO_Init(&spi2_handle,&spi2);
//}
//void SPI2_INIT(void)
//{
//
//	spi2_handle.SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
//	spi2_handle.SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_MASTER_FD;
//	spi2_handle.SPIConfig.SPI_SclkSpeed= SPI_SCLK_SPEED_DIV4;
//	spi2_handle.SPIConfig.SPI_DFF = SPI_DFF_8BITS;
//	spi2_handle.SPIConfig.SPI_CPOL = SPI_CPOL_HIGH; //idle state is high
//	spi2_handle.SPIConfig.SPI_CPHA = SPI_CPHA_LOW;//data taken at 1st edge
//	spi2_handle.SPIConfig.SPI_SSM = 0;;
//	spi2_handle.SPIConfig.NSS_Port = GPIOA;
//	spi2_handle.SPIConfig.NSS_Pin = 4;
//
//	SPI_Init(&spi2_handle);
//
//
//}
//int main(void) {
//	// Initialize the system clock
//	MCU_Clock_Setup();
//
//	//uint8_t user_data[] = "Hello World";
//
//	spi2_handle.pSPIx = SPI2;
//	spi2.pGPIOx = GPIOB;
//	spi2.pGPIOx = GPIOA;
//	//SPI_Handle_t spi2_handle;
//	GPIO_ClockControl(GPIOA);
//	//GPIO_ClockControl(GPIOB);
//
//	spi2.SPIConfig.clock_pin = 13;
//	spi2.SPIConfig.mosi_pin = 15;
//	spi2.SPIConfig.miso_pin = 14;
//
//
//	SPI2_INIT();
//	SPI2_GPIO_INIT();
//
//
//	// Reset SPI configuration to default values
//	int8_t result = SPI_Configuration_Reset(&spiHandle);
//
//	// Check if the reset was successful
//	if (result == -1) {
//		// Handle error (invalid SPI peripheral)
//
//		while (1);
//	}
//	SPI_Disable(&spi2_handle);
//
//
//}

